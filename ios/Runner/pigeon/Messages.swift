// Autogenerated from Pigeon (v17.1.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Generated class from Pigeon that represents data sent in messages.
struct ViewMessage {
  var viewId: Int64? = nil

  static func fromList(_ list: [Any?]) -> ViewMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))

    return ViewMessage(
      viewId: viewId
    )
  }
  func toList() -> [Any?] {
    return [
      viewId
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct CreateMessage {
  var viewId: Int64? = nil
  var uri: String? = nil
  var type: Int64? = nil
  var packageName: String? = nil
  var autoPlay: Bool? = nil
  var hwAcc: Int64? = nil
  var options: [String?]? = nil

  static func fromList(_ list: [Any?]) -> CreateMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let uri: String? = nilOrValue(list[1])
    let type: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let packageName: String? = nilOrValue(list[3])
    let autoPlay: Bool? = nilOrValue(list[4])
    let hwAcc: Int64? = isNullish(list[5]) ? nil : (list[5] is Int64? ? list[5] as! Int64? : Int64(list[5] as! Int32))
    let options: [String?]? = nilOrValue(list[6])

    return CreateMessage(
      viewId: viewId,
      uri: uri,
      type: type,
      packageName: packageName,
      autoPlay: autoPlay,
      hwAcc: hwAcc,
      options: options
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      uri,
      type,
      packageName,
      autoPlay,
      hwAcc,
      options,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SetMediaMessage {
  var viewId: Int64? = nil
  var uri: String? = nil
  var type: Int64? = nil
  var packageName: String? = nil
  var autoPlay: Bool? = nil
  var hwAcc: Int64? = nil

  static func fromList(_ list: [Any?]) -> SetMediaMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let uri: String? = nilOrValue(list[1])
    let type: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let packageName: String? = nilOrValue(list[3])
    let autoPlay: Bool? = nilOrValue(list[4])
    let hwAcc: Int64? = isNullish(list[5]) ? nil : (list[5] is Int64? ? list[5] as! Int64? : Int64(list[5] as! Int32))

    return SetMediaMessage(
      viewId: viewId,
      uri: uri,
      type: type,
      packageName: packageName,
      autoPlay: autoPlay,
      hwAcc: hwAcc
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      uri,
      type,
      packageName,
      autoPlay,
      hwAcc,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct BooleanMessage {
  var viewId: Int64? = nil
  var result: Bool? = nil

  static func fromList(_ list: [Any?]) -> BooleanMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let result: Bool? = nilOrValue(list[1])

    return BooleanMessage(
      viewId: viewId,
      result: result
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      result,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LoopingMessage {
  var viewId: Int64? = nil
  var isLooping: Bool? = nil

  static func fromList(_ list: [Any?]) -> LoopingMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let isLooping: Bool? = nilOrValue(list[1])

    return LoopingMessage(
      viewId: viewId,
      isLooping: isLooping
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      isLooping,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct VolumeMessage {
  var viewId: Int64? = nil
  var volume: Int64? = nil

  static func fromList(_ list: [Any?]) -> VolumeMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let volume: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return VolumeMessage(
      viewId: viewId,
      volume: volume
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      volume,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlaybackSpeedMessage {
  var viewId: Int64? = nil
  var speed: Double? = nil

  static func fromList(_ list: [Any?]) -> PlaybackSpeedMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let speed: Double? = nilOrValue(list[1])

    return PlaybackSpeedMessage(
      viewId: viewId,
      speed: speed
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      speed,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PositionMessage {
  var viewId: Int64? = nil
  var position: Int64? = nil

  static func fromList(_ list: [Any?]) -> PositionMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let position: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return PositionMessage(
      viewId: viewId,
      position: position
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      position,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DurationMessage {
  var viewId: Int64? = nil
  var duration: Int64? = nil

  static func fromList(_ list: [Any?]) -> DurationMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let duration: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return DurationMessage(
      viewId: viewId,
      duration: duration
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      duration,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DelayMessage {
  var viewId: Int64? = nil
  var delay: Int64? = nil

  static func fromList(_ list: [Any?]) -> DelayMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let delay: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return DelayMessage(
      viewId: viewId,
      delay: delay
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      delay,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct TrackCountMessage {
  var viewId: Int64? = nil
  var count: Int64? = nil

  static func fromList(_ list: [Any?]) -> TrackCountMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let count: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return TrackCountMessage(
      viewId: viewId,
      count: count
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      count,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SnapshotMessage {
  var viewId: Int64? = nil
  var snapshot: String? = nil

  static func fromList(_ list: [Any?]) -> SnapshotMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let snapshot: String? = nilOrValue(list[1])

    return SnapshotMessage(
      viewId: viewId,
      snapshot: snapshot
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      snapshot,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SpuTracksMessage {
  var viewId: Int64? = nil
  var subtitles: [Any?: Any?]? = nil

  static func fromList(_ list: [Any?]) -> SpuTracksMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let subtitles: [Any?: Any?]? = nilOrValue(list[1])

    return SpuTracksMessage(
      viewId: viewId,
      subtitles: subtitles
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      subtitles,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SpuTrackMessage {
  var viewId: Int64? = nil
  var spuTrackNumber: Int64? = nil

  static func fromList(_ list: [Any?]) -> SpuTrackMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let spuTrackNumber: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return SpuTrackMessage(
      viewId: viewId,
      spuTrackNumber: spuTrackNumber
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      spuTrackNumber,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AddSubtitleMessage {
  var viewId: Int64? = nil
  var uri: String? = nil
  var type: Int64? = nil
  var isSelected: Bool? = nil

  static func fromList(_ list: [Any?]) -> AddSubtitleMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let uri: String? = nilOrValue(list[1])
    let type: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let isSelected: Bool? = nilOrValue(list[3])

    return AddSubtitleMessage(
      viewId: viewId,
      uri: uri,
      type: type,
      isSelected: isSelected
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      uri,
      type,
      isSelected,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AudioTracksMessage {
  var viewId: Int64? = nil
  var audios: [Any?: Any?]? = nil

  static func fromList(_ list: [Any?]) -> AudioTracksMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let audios: [Any?: Any?]? = nilOrValue(list[1])

    return AudioTracksMessage(
      viewId: viewId,
      audios: audios
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      audios,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AudioTrackMessage {
  var viewId: Int64? = nil
  var audioTrackNumber: Int64? = nil

  static func fromList(_ list: [Any?]) -> AudioTrackMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let audioTrackNumber: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return AudioTrackMessage(
      viewId: viewId,
      audioTrackNumber: audioTrackNumber
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      audioTrackNumber,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AddAudioMessage {
  var viewId: Int64? = nil
  var uri: String? = nil
  var type: Int64? = nil
  var isSelected: Bool? = nil

  static func fromList(_ list: [Any?]) -> AddAudioMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let uri: String? = nilOrValue(list[1])
    let type: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let isSelected: Bool? = nilOrValue(list[3])

    return AddAudioMessage(
      viewId: viewId,
      uri: uri,
      type: type,
      isSelected: isSelected
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      uri,
      type,
      isSelected,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct VideoTracksMessage {
  var viewId: Int64? = nil
  var videos: [Any?: Any?]? = nil

  static func fromList(_ list: [Any?]) -> VideoTracksMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let videos: [Any?: Any?]? = nilOrValue(list[1])

    return VideoTracksMessage(
      viewId: viewId,
      videos: videos
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      videos,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct VideoTrackMessage {
  var viewId: Int64? = nil
  var videoTrackNumber: Int64? = nil

  static func fromList(_ list: [Any?]) -> VideoTrackMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let videoTrackNumber: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return VideoTrackMessage(
      viewId: viewId,
      videoTrackNumber: videoTrackNumber
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      videoTrackNumber,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct VideoScaleMessage {
  var viewId: Int64? = nil
  var scale: Double? = nil

  static func fromList(_ list: [Any?]) -> VideoScaleMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let scale: Double? = nilOrValue(list[1])

    return VideoScaleMessage(
      viewId: viewId,
      scale: scale
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      scale,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct VideoAspectRatioMessage {
  var viewId: Int64? = nil
  var aspectRatio: String? = nil

  static func fromList(_ list: [Any?]) -> VideoAspectRatioMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let aspectRatio: String? = nilOrValue(list[1])

    return VideoAspectRatioMessage(
      viewId: viewId,
      aspectRatio: aspectRatio
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      aspectRatio,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RendererServicesMessage {
  var viewId: Int64? = nil
  var services: [String?]? = nil

  static func fromList(_ list: [Any?]) -> RendererServicesMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let services: [String?]? = nilOrValue(list[1])

    return RendererServicesMessage(
      viewId: viewId,
      services: services
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      services,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RendererScanningMessage {
  var viewId: Int64? = nil
  var rendererService: String? = nil

  static func fromList(_ list: [Any?]) -> RendererScanningMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let rendererService: String? = nilOrValue(list[1])

    return RendererScanningMessage(
      viewId: viewId,
      rendererService: rendererService
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      rendererService,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RendererDevicesMessage {
  var viewId: Int64? = nil
  var rendererDevices: [Any?: Any?]? = nil

  static func fromList(_ list: [Any?]) -> RendererDevicesMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let rendererDevices: [Any?: Any?]? = nilOrValue(list[1])

    return RendererDevicesMessage(
      viewId: viewId,
      rendererDevices: rendererDevices
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      rendererDevices,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RenderDeviceMessage {
  var viewId: Int64? = nil
  var rendererDevice: String? = nil

  static func fromList(_ list: [Any?]) -> RenderDeviceMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let rendererDevice: String? = nilOrValue(list[1])

    return RenderDeviceMessage(
      viewId: viewId,
      rendererDevice: rendererDevice
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      rendererDevice,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RecordMessage {
  var viewId: Int64? = nil
  var saveDirectory: String? = nil

  static func fromList(_ list: [Any?]) -> RecordMessage? {
    let viewId: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let saveDirectory: String? = nilOrValue(list[1])

    return RecordMessage(
      viewId: viewId,
      saveDirectory: saveDirectory
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      saveDirectory,
    ]
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol FlutterTextApiHandlerProtocol {
  func textChanged(text textArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)
}
class FlutterTextApiHandler: FlutterTextApiHandlerProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }
  func textChanged(text textArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_vlc_player_platform_interface.FlutterTextApiHandler.textChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger)
    channel.sendMessage([textArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
private class VlcPlayerApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AddAudioMessage.fromList(self.readValue() as! [Any?])
    case 129:
      return AddSubtitleMessage.fromList(self.readValue() as! [Any?])
    case 130:
      return AudioTrackMessage.fromList(self.readValue() as! [Any?])
    case 131:
      return AudioTracksMessage.fromList(self.readValue() as! [Any?])
    case 132:
      return BooleanMessage.fromList(self.readValue() as! [Any?])
    case 133:
      return CreateMessage.fromList(self.readValue() as! [Any?])
    case 134:
      return DelayMessage.fromList(self.readValue() as! [Any?])
    case 135:
      return DurationMessage.fromList(self.readValue() as! [Any?])
    case 136:
      return LoopingMessage.fromList(self.readValue() as! [Any?])
    case 137:
      return PlaybackSpeedMessage.fromList(self.readValue() as! [Any?])
    case 138:
      return PositionMessage.fromList(self.readValue() as! [Any?])
    case 139:
      return RecordMessage.fromList(self.readValue() as! [Any?])
    case 140:
      return RenderDeviceMessage.fromList(self.readValue() as! [Any?])
    case 141:
      return RendererDevicesMessage.fromList(self.readValue() as! [Any?])
    case 142:
      return RendererScanningMessage.fromList(self.readValue() as! [Any?])
    case 143:
      return RendererServicesMessage.fromList(self.readValue() as! [Any?])
    case 144:
      return SetMediaMessage.fromList(self.readValue() as! [Any?])
    case 145:
      return SnapshotMessage.fromList(self.readValue() as! [Any?])
    case 146:
      return SpuTrackMessage.fromList(self.readValue() as! [Any?])
    case 147:
      return SpuTracksMessage.fromList(self.readValue() as! [Any?])
    case 148:
      return TrackCountMessage.fromList(self.readValue() as! [Any?])
    case 149:
      return VideoAspectRatioMessage.fromList(self.readValue() as! [Any?])
    case 150:
      return VideoScaleMessage.fromList(self.readValue() as! [Any?])
    case 151:
      return VideoTrackMessage.fromList(self.readValue() as! [Any?])
    case 152:
      return VideoTracksMessage.fromList(self.readValue() as! [Any?])
    case 153:
      return ViewMessage.fromList(self.readValue() as! [Any?])
    case 154:
      return VolumeMessage.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class VlcPlayerApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AddAudioMessage {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? AddSubtitleMessage {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? AudioTrackMessage {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? AudioTracksMessage {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? BooleanMessage {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? CreateMessage {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? DelayMessage {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? DurationMessage {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? LoopingMessage {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? PlaybackSpeedMessage {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? PositionMessage {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? RecordMessage {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? RenderDeviceMessage {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? RendererDevicesMessage {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? RendererScanningMessage {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? RendererServicesMessage {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? SetMediaMessage {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? SnapshotMessage {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? SpuTrackMessage {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? SpuTracksMessage {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? TrackCountMessage {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? VideoAspectRatioMessage {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? VideoScaleMessage {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? VideoTrackMessage {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else if let value = value as? VideoTracksMessage {
      super.writeByte(152)
      super.writeValue(value.toList())
    } else if let value = value as? ViewMessage {
      super.writeByte(153)
      super.writeValue(value.toList())
    } else if let value = value as? VolumeMessage {
      super.writeByte(154)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class VlcPlayerApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return VlcPlayerApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return VlcPlayerApiCodecWriter(data: data)
  }
}

class VlcPlayerApiCodec: FlutterStandardMessageCodec {
  static let shared = VlcPlayerApiCodec(readerWriter: VlcPlayerApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol VlcPlayerApi {
  func initialize() throws
  func create(msg: CreateMessage) throws
  func dispose(msg: ViewMessage) throws
  func setStreamUrl(msg: SetMediaMessage) throws
  func play(msg: ViewMessage) throws
  func pause(msg: ViewMessage) throws
  func stop(msg: ViewMessage) throws
  func isPlaying(msg: ViewMessage) throws -> BooleanMessage
  func isSeekable(msg: ViewMessage) throws -> BooleanMessage
  func setLooping(msg: LoopingMessage) throws
  func seekTo(msg: PositionMessage) throws
  func position(msg: ViewMessage) throws -> PositionMessage
  func duration(msg: ViewMessage) throws -> DurationMessage
  func setVolume(msg: VolumeMessage) throws
  func getVolume(msg: ViewMessage) throws -> VolumeMessage
  func setPlaybackSpeed(msg: PlaybackSpeedMessage) throws
  func getPlaybackSpeed(msg: ViewMessage) throws -> PlaybackSpeedMessage
  func takeSnapshot(msg: ViewMessage) throws -> SnapshotMessage
  func getSpuTracksCount(msg: ViewMessage) throws -> TrackCountMessage
  func getSpuTracks(msg: ViewMessage) throws -> SpuTracksMessage
  func setSpuTrack(msg: SpuTrackMessage) throws
  func getSpuTrack(msg: ViewMessage) throws -> SpuTrackMessage
  func setSpuDelay(msg: DelayMessage) throws
  func getSpuDelay(msg: ViewMessage) throws -> DelayMessage
  func addSubtitleTrack(msg: AddSubtitleMessage) throws
  func getAudioTracksCount(msg: ViewMessage) throws -> TrackCountMessage
  func getAudioTracks(msg: ViewMessage) throws -> AudioTracksMessage
  func setAudioTrack(msg: AudioTrackMessage) throws
  func getAudioTrack(msg: ViewMessage) throws -> AudioTrackMessage
  func setAudioDelay(msg: DelayMessage) throws
  func getAudioDelay(msg: ViewMessage) throws -> DelayMessage
  func addAudioTrack(msg: AddAudioMessage) throws
  func getVideoTracksCount(msg: ViewMessage) throws -> TrackCountMessage
  func getVideoTracks(msg: ViewMessage) throws -> VideoTracksMessage
  func setVideoTrack(msg: VideoTrackMessage) throws
  func getVideoTrack(msg: ViewMessage) throws -> VideoTrackMessage
  func setVideoScale(msg: VideoScaleMessage) throws
  func getVideoScale(msg: ViewMessage) throws -> VideoScaleMessage
  func setVideoAspectRatio(msg: VideoAspectRatioMessage) throws
  func getVideoAspectRatio(msg: ViewMessage) throws -> VideoAspectRatioMessage
  func getAvailableRendererServices(msg: ViewMessage) throws -> RendererServicesMessage
  func startRendererScanning(msg: RendererScanningMessage) throws
  func stopRendererScanning(msg: ViewMessage) throws
  func getRendererDevices(msg: ViewMessage) throws -> RendererDevicesMessage
  func castToRenderer(msg: RenderDeviceMessage) throws
  func startRecording(msg: RecordMessage) throws -> BooleanMessage
  func stopRecording(msg: ViewMessage) throws -> BooleanMessage
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class VlcPlayerApiSetup {
  /// The codec used by VlcPlayerApi.
  static var codec: FlutterStandardMessageCodec { VlcPlayerApiCodec.shared }
  /// Sets up an instance of `VlcPlayerApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: VlcPlayerApi?) {
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.initialize", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { _, reply in
        do {
          try api.initialize()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! CreateMessage
        do {
          try api.create(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.dispose", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          try api.dispose(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    let setStreamUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setStreamUrl", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStreamUrlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! SetMediaMessage
        do {
          try api.setStreamUrl(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setStreamUrlChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          try api.play(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          try api.pause(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.stop", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          try api.stop(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    let isPlayingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.isPlaying", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPlayingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.isPlaying(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isPlayingChannel.setMessageHandler(nil)
    }
    let isSeekableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.isSeekable", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isSeekableChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.isSeekable(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isSeekableChannel.setMessageHandler(nil)
    }
    let setLoopingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setLooping", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLoopingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! LoopingMessage
        do {
          try api.setLooping(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLoopingChannel.setMessageHandler(nil)
    }
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.seekTo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! PositionMessage
        do {
          try api.seekTo(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    let positionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.position", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      positionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.position(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      positionChannel.setMessageHandler(nil)
    }
    let durationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.duration", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      durationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.duration(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      durationChannel.setMessageHandler(nil)
    }
    let setVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setVolume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! VolumeMessage
        do {
          try api.setVolume(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVolumeChannel.setMessageHandler(nil)
    }
    let getVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getVolume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getVolume(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVolumeChannel.setMessageHandler(nil)
    }
    let setPlaybackSpeedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setPlaybackSpeed", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPlaybackSpeedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! PlaybackSpeedMessage
        do {
          try api.setPlaybackSpeed(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPlaybackSpeedChannel.setMessageHandler(nil)
    }
    let getPlaybackSpeedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getPlaybackSpeed", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlaybackSpeedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getPlaybackSpeed(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPlaybackSpeedChannel.setMessageHandler(nil)
    }
    let takeSnapshotChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.takeSnapshot", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takeSnapshotChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.takeSnapshot(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      takeSnapshotChannel.setMessageHandler(nil)
    }
    let getSpuTracksCountChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getSpuTracksCount", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpuTracksCountChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getSpuTracksCount(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSpuTracksCountChannel.setMessageHandler(nil)
    }
    let getSpuTracksChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getSpuTracks", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpuTracksChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getSpuTracks(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSpuTracksChannel.setMessageHandler(nil)
    }
    let setSpuTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setSpuTrack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSpuTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! SpuTrackMessage
        do {
          try api.setSpuTrack(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setSpuTrackChannel.setMessageHandler(nil)
    }
    let getSpuTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getSpuTrack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpuTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getSpuTrack(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSpuTrackChannel.setMessageHandler(nil)
    }
    let setSpuDelayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setSpuDelay", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSpuDelayChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! DelayMessage
        do {
          try api.setSpuDelay(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setSpuDelayChannel.setMessageHandler(nil)
    }
    let getSpuDelayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getSpuDelay", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSpuDelayChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getSpuDelay(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSpuDelayChannel.setMessageHandler(nil)
    }
    let addSubtitleTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.addSubtitleTrack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addSubtitleTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! AddSubtitleMessage
        do {
          try api.addSubtitleTrack(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addSubtitleTrackChannel.setMessageHandler(nil)
    }
    let getAudioTracksCountChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getAudioTracksCount", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAudioTracksCountChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getAudioTracksCount(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAudioTracksCountChannel.setMessageHandler(nil)
    }
    let getAudioTracksChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getAudioTracks", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAudioTracksChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getAudioTracks(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAudioTracksChannel.setMessageHandler(nil)
    }
    let setAudioTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setAudioTrack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAudioTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! AudioTrackMessage
        do {
          try api.setAudioTrack(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAudioTrackChannel.setMessageHandler(nil)
    }
    let getAudioTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getAudioTrack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAudioTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getAudioTrack(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAudioTrackChannel.setMessageHandler(nil)
    }
    let setAudioDelayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setAudioDelay", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAudioDelayChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! DelayMessage
        do {
          try api.setAudioDelay(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAudioDelayChannel.setMessageHandler(nil)
    }
    let getAudioDelayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getAudioDelay", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAudioDelayChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getAudioDelay(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAudioDelayChannel.setMessageHandler(nil)
    }
    let addAudioTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.addAudioTrack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addAudioTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! AddAudioMessage
        do {
          try api.addAudioTrack(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addAudioTrackChannel.setMessageHandler(nil)
    }
    let getVideoTracksCountChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getVideoTracksCount", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoTracksCountChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getVideoTracksCount(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoTracksCountChannel.setMessageHandler(nil)
    }
    let getVideoTracksChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getVideoTracks", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoTracksChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getVideoTracks(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoTracksChannel.setMessageHandler(nil)
    }
    let setVideoTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setVideoTrack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! VideoTrackMessage
        do {
          try api.setVideoTrack(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVideoTrackChannel.setMessageHandler(nil)
    }
    let getVideoTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getVideoTrack", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getVideoTrack(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoTrackChannel.setMessageHandler(nil)
    }
    let setVideoScaleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setVideoScale", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoScaleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! VideoScaleMessage
        do {
          try api.setVideoScale(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVideoScaleChannel.setMessageHandler(nil)
    }
    let getVideoScaleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getVideoScale", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoScaleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getVideoScale(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoScaleChannel.setMessageHandler(nil)
    }
    let setVideoAspectRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.setVideoAspectRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVideoAspectRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! VideoAspectRatioMessage
        do {
          try api.setVideoAspectRatio(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVideoAspectRatioChannel.setMessageHandler(nil)
    }
    let getVideoAspectRatioChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getVideoAspectRatio", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVideoAspectRatioChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getVideoAspectRatio(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVideoAspectRatioChannel.setMessageHandler(nil)
    }
    let getAvailableRendererServicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getAvailableRendererServices", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAvailableRendererServicesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getAvailableRendererServices(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAvailableRendererServicesChannel.setMessageHandler(nil)
    }
    let startRendererScanningChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.startRendererScanning", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startRendererScanningChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! RendererScanningMessage
        do {
          try api.startRendererScanning(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startRendererScanningChannel.setMessageHandler(nil)
    }
    let stopRendererScanningChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.stopRendererScanning", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopRendererScanningChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          try api.stopRendererScanning(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopRendererScanningChannel.setMessageHandler(nil)
    }
    let getRendererDevicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.getRendererDevices", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getRendererDevicesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.getRendererDevices(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getRendererDevicesChannel.setMessageHandler(nil)
    }
    let castToRendererChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.castToRenderer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      castToRendererChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! RenderDeviceMessage
        do {
          try api.castToRenderer(msg: msgArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      castToRendererChannel.setMessageHandler(nil)
    }
    let startRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.startRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! RecordMessage
        do {
          let result = try api.startRecording(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startRecordingChannel.setMessageHandler(nil)
    }
    let stopRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_vlc_player_platform_interface.VlcPlayerApi.stopRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let msgArg = args[0] as! ViewMessage
        do {
          let result = try api.stopRecording(msg: msgArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopRecordingChannel.setMessageHandler(nil)
    }
  }
}
